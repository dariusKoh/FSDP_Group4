const PDFDocument = require("pdfkit");
const { queryDataByproj_id } = require("./query-db");

// PDF Builder
function buildTestReport(doc, testData) {
	// Layout Constants
	const PAGE_MARGIN = 50;
	const LINE_HEIGHT = 24;
	const PAGE_WIDTH = 612;
	const PAGE_HEIGHT = 792;
	const CONTENT_WIDTH = PAGE_WIDTH - PAGE_MARGIN * 2;

	// Visual Settings
	const COLORS = {
		primary: "#2C3E50",
		secondary: "#3498DB",
		text: "#333333",
	};

	// Trackers
	let currentPage = 1;
	let yPosition = PAGE_MARGIN;

	// Helper Functions
	const spaceCheck = (neededHeight) => {
		const footerBuffer = 40;
		if (yPosition + neededHeight + footerBuffer > PAGE_HEIGHT) {
			addContentFooter();
			doc.addPage();
			yPosition = PAGE_MARGIN;
			currentPage++;
			drawContentBorder();
		}
	};

	const drawContentBorder = () => {
		doc.rect(PAGE_MARGIN - 10, PAGE_MARGIN - 10, CONTENT_WIDTH + 20, 700)
			.strokeColor("#EEEEEE")
			.lineWidth(0.5)
			.stroke();
	};

	const addContentFooter = () => {
		doc.save()
			.fontSize(10)
			.fillColor("#666666")
			.text(
				`Page ${currentPage}`,
				PAGE_WIDTH - PAGE_MARGIN,
				PAGE_HEIGHT - 35,
				{ align: "right" }
			)
			.restore();
	};

	// Cover Page
	function createCoverPage() {
		// Main Title
		doc.fontSize(36)
			.fillColor(COLORS.primary)
			.font("Helvetica-Bold")
			.text("QA Automation Report", PAGE_MARGIN, 150, {
				align: "left",
				width: CONTENT_WIDTH,
			});

		// Project Name
		doc.fontSize(28)
			.fillColor(COLORS.secondary)
			.text("Automation Test", PAGE_MARGIN, 230, {
				align: "left",
				width: CONTENT_WIDTH,
			});

		// Decorative Line
		doc.moveTo(PAGE_MARGIN, 300)
			.lineTo(PAGE_WIDTH - PAGE_MARGIN, 300)
			.strokeColor(COLORS.primary)
			.lineWidth(2)
			.stroke();

		// Metadata
		doc.fontSize(16)
			.fillColor(COLORS.text)
			.text("Report Date:", PAGE_MARGIN, 350)
			.text(new Date().toLocaleDateString(), PAGE_MARGIN + 120, 350)

			.text("Test Cases:", PAGE_MARGIN, 390)
			.text(testData.length, PAGE_MARGIN + 120, 390)

			.text("Generated By:", PAGE_MARGIN, 430)
			.text("QA Automation Team", PAGE_MARGIN + 120, 430);

		// Cover Footer
		doc.fontSize(12)
			.fillColor("#888888")
			.text(
				"Confidential - Internal Use Only",
				PAGE_MARGIN,
				PAGE_HEIGHT - 60
			)
			.text("Â© 2024 Your Company Name", PAGE_MARGIN);
	}

	// Create initial cover page
	createCoverPage();
	currentPage++;
	doc.addPage(); // Start content on new page

	// Test Case Pages
	testData.forEach((testCase, index) => {
		if (index > 0) {
			doc.addPage();
			yPosition = PAGE_MARGIN;
			currentPage++;
		}

		drawContentBorder();

		// Test Case Header
		spaceCheck(100);
		doc.font("Helvetica-Bold")
			.fillColor(COLORS.text)
			.fontSize(18)
			.text(`Test Case #${index + 1}`, PAGE_MARGIN, yPosition);
		yPosition += LINE_HEIGHT * 1.5;

		// Basic Info Columns
		const infoLeft = PAGE_MARGIN;
		const infoRight = PAGE_MARGIN + 250;

		doc.font("Helvetica")
			.fillColor(COLORS.text)
			.fontSize(12)
			.text("Test ID:", infoLeft, yPosition)
			.text(testCase.testId, infoLeft + 60, yPosition)

			.text("Status:", infoRight, yPosition)
			.fillColor(testCase.status === "PASSED" ? COLORS.pass : COLORS.fail)
			.text(testCase.status, infoRight + 50, yPosition)
			.fillColor(COLORS.text);

		yPosition += LINE_HEIGHT * 1.2;

		doc.text("Date:", infoLeft, yPosition)
			.text(
				new Date(testCase.createdAt).toLocaleString(),
				infoLeft + 60,
				yPosition
			)

			.text("Duration:", infoRight, yPosition)
			.text(`${testCase.duration}ms`, infoRight + 50, yPosition);

		yPosition += LINE_HEIGHT * 2;

		// Test Details
		spaceCheck(150);
		doc.font("Helvetica-Bold").text("Test Details", PAGE_MARGIN, yPosition);
		yPosition += LINE_HEIGHT;

		const detailsContent = [
			`Category: ${testCase.ancestorTitles || "General"}`,
			`Scenario: ${testCase.fullTitle || "Unnamed Test"}`,
		];

		detailsContent.forEach((line) => {
			const textHeight = doc
				.font("Helvetica")
				.fontSize(12)
				.heightOfString(line, { width: CONTENT_WIDTH });
			spaceCheck(textHeight);
			doc.text(line, PAGE_MARGIN, yPosition);
			yPosition += textHeight + 5;
		});

		yPosition += LINE_HEIGHT;

		// Failure Analysis
		if (testCase.status !== "PASSED") {
			spaceCheck(200);
			doc.font("Helvetica-Bold").text(
				"Issue Breakdown",
				PAGE_MARGIN,
				yPosition
			);
			yPosition += LINE_HEIGHT;

			const failureContent = [
				{ label: "Error Messages:", text: testCase.failureMessages },
				{ label: "Technical Details:", text: testCase.failureDetails },
			];

			failureContent.forEach(({ label, text }) => {
				const labelHeight = doc
					.font("Helvetica-Bold")
					.fontSize(12)
					.heightOfString(label);
				const textHeight = doc
					.font("Helvetica")
					.fontSize(12)
					.heightOfString(text, {
						width: CONTENT_WIDTH - 20,
					});

				spaceCheck(labelHeight + textHeight + 15);

				doc.fillColor(COLORS.fail)
					.text(label, PAGE_MARGIN + 10, yPosition)
					.fillColor(COLORS.text);

				yPosition += labelHeight + 5;

				doc.text(text, PAGE_MARGIN + 20, yPosition, {
					width: CONTENT_WIDTH - 40,
					indent: 5,
				});

				yPosition += textHeight + 15;
			});
		}

		// Summary Section
		const summaryText = testCase.summary || "No summary provided";
		const summaryHeight = doc
			.font("Helvetica")
			.fontSize(12)
			.heightOfString(summaryText, {
				width: CONTENT_WIDTH - 20,
			});

		spaceCheck(summaryHeight + 50);

		doc.save()
			.rect(
				PAGE_MARGIN,
				yPosition,
				CONTENT_WIDTH,
				PAGE_HEIGHT - yPosition - 60
			)
			.clip()
			.font("Helvetica-Bold")
			.text("Key Takeaways:", PAGE_MARGIN, yPosition)
			.font("Helvetica")
			.text(summaryText, PAGE_MARGIN + 10, yPosition + 20, {
				width: CONTENT_WIDTH - 20,
				indent: 5,
				align: "justify",
			})
			.restore();

		// Final Footer
		addContentFooter();
	});

	return doc;
}

async function generatePDF(response, testData) {
	return new Promise((resolve, reject) => {
		try {
			const doc = new PDFDocument();

			buildTestReport(doc, testData);

			// Set PDF metadata and headers directly on the response
			response.setHeader("Content-Type", "application/pdf");
			response.setHeader(
				"Content-Disposition",
				`attachment; filename="Test_Report_${Date.now()}.pdf"`
			);

			// Pipe directly to HTTP response
			doc.pipe(response);

			// PDF Content

			// Finalize the PDF
			doc.end();

			// Resolve when PDF generation completes
			doc.on("end", () => resolve());
		} catch (error) {
			reject(error);
		}
	});
}

module.exports = { generatePDF };
